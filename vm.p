; PAL - virtual machine  
;                written by  dewa    Feb 14 1991

; Make vector length n

(as (nlengthlist 0 ())(cut))
(as (nlengthlist *i (\? . *l))
    (> *i 0)
    (sub1 *i *i1)
    (nlengthlist *i1 *l))

; Initialize vector named *name

(as (init *n *name)
    (nlengthlist *n *l)
    (vector *l *v)
    (set *name *v))
(as (initparea)
    (init 100 PAREA))
(as (init_vm)
    (init 50 REG)
    (init 400 RS)
    (init 100 PAREA)
    (init 100 HEAP)
    (init 1000 TRAIL)
    (setv NEWATOM 300)
    (setv HEAPTAG 1000)
    (setv GVARTAG 10000)
    (setv DEBUG_FLAG 0)
    (setv PRINT_FLAG 0)
    (init 400 COMMENT)
    (setv PCOUNTER 0)
;PCOUNTER P-code load position
    (setv QCOUNTER 0)
;QCOUNTER query load position
    (setv PC 0)
    (setv ENVREG 0)
    (setv RETREG 0)
    (setv BREG -1)
    (setv HREG 0)
    (setv RREG 0)
    (setv TRREG 0)
    (setv SREG 0)
    (setv READ 0)
    (setv WRITE 1)
; 0 ... readmode 1 ... writemode
    (setv ON 1)
    (setv OFF 0)
    (setv HEAPFLAG OFF)
    (setv MODE_FLAG READ))

(as (init_stack)
    (init 50 REG)
    (init 400 RS)
    (init 100 HEAP)
    (init 1000 TRAIL)
    (setv ENVREG 0)
    (setv RETREG 0)
    (setv BREG -1)
    (setv HREG 0)
    (setv TRREG 0)
    (setv RREG 0)
    (setv SREG 0)
    (setv MODE_FLAG READ)
    (init 400 COMMENT))

(as (++ *C) (setv *C (+ 1 *C)))
(as (-- *C) (setv *C (- 1 *C)))

; Main loop --  Program sequence 
(as (vm)
    (init_vm)
    (PAREA *)
    (cut)
    (repeat)
    (rind "vm: " *q)
    (if (== *q end) (true) (dexecs ((com *q))) (false)))

(as (exec_loop)
    (=:= DEBUG_FLAG 1)
    (PAREA *)
    (repeat)
    (nth * PC *cmd)
    (++ PC)
    (if (debug *cmd) (=:= PC PCOUNTER) (backtrack))) 
(as (exec_loop)
    (=:= DEBUG_FLAG 0)
    (PAREA *)
    (repeat)
    (nth * PC *cmd)
    (++ PC)
    (if *cmd (=:= PC PCOUNTER) (backtrack))) 

(as (backtrack)
    (=:= BREG -1)
    (print "failure")
    (setv PC PCOUNTER))
(as (backtrack)
    (=/= BREG -1)
; If BREG is zero then failure
    (RS *st)
    (nth *st (- BREG 1) *nextcl)
    (setv PC *nextcl)
    (cut)(false))

; vm command input
; query / load / parea / stack / manual / loadq / debug / comment / heap
(as (com debug)
    (cut)
    (if (=:= DEBUG_FLAG 0)
	(and (print "debug mode ON!")
	     (setv DEBUG_FLAG 1))
      (print "debug mode OFF!")
      (setv DEBUG_FLAG 0)))
(as (com comment)
    (cut)
    (if (=:= PRINT_FLAG 0)
	(and (print "Comment ON!")
	     (setv PRINT_FLAG 1))
      (print "Comment OFF!")
      (setv PRINT_FLAG 0)))
;--- prolog query read
(as (com query)
    (cut)
    (rind "query: " *q)
    (varsin *q *vars)
    (= *defs ((dummy *num (*vars *q))))
    (trans_defs *defs *prags)
    (gen_inst_defs *prags *insts ())

    (setv PC QCOUNTER)
    (setv PCOUNTER QCOUNTER)
    (set_insts *insts)
    (init_stack)
    (querycall *num)
    (exec_loop)
    (cut))
;--- prolog file load
(as (com load)
    (cut)
    (rind "file: " *f)
    (compile *f *inst)
    (setv PCOUNTER 0)
    (true (retract LABEL_TAB))
    (initparea)
    (set_insts *inst)
    (setv QCOUNTER PCOUNTER)
    (cut))
;--- compile program file load
(as (com manual)
    (cut)
    (rind "file: " *f)
    (fopen *f *h)
    (readinst *h *inst)
    (fclose *h)
    (setv PCOUNTER 0)
    (initparea)
    (true (retract LABEL_TAB))
    (set_insts *inst)
    (setv QCOUNTER PCOUNTER)
    (cut))
;---- compiled query file load
(as (com loadq)
    (cut)
    (rind "queryfile: " *f)
    (fopen *f *h)
    (readinst *h *inst)
    (fclose *h)
    (setv PC QCOUNTER)
    (setv PCOUNTER QCOUNTER)
    (set_insts *inst)
    (init_stack)
    (exec_loop)
    (cut))
;---- display parea
(as (com parea)
    (cut)
    (print_parea)
    (cut))
(as (com stack)
    (cut)
    (print_stack)
    (cut))
(as (com heap)
    (cut)
    (print_heap)
    (cut))

;Display parea
(as (print_parea)
    (format "/n*** PAREA ***/n") 
    (PAREA *v)
    (print_parea1 0 *v))

(as (print_parea1 *n *v)
    (nth *v *n \?) 
    (cut))
(as (print_parea1 *n *v)
    (nth *v *n *val)
    (format "/a : /p/n" *n *val)
    (add1 *n *n1)
    (print_parea1 *n1 *v))

;Display stack
(as (print_stack)
    (rind "How many?" *num)
    (format "/n*** STACK ***/n") 
    (print_stack1 2 *num))

(as (print_stack1 *n *num)
    (== *n *num) 
    (cut))
(as (print_stack1 *n *num)
    (RS *v)
    (COMMENT *comt)
    (nth *v *n *val)
    (nth *comt *n *comment)
    (format "/a : /p ;/p/n" *n *val *comment)
    (add1 *n *n1)
    (print_stack1 *n1 *num))

;Display heap
(as (print_heap)
    (rind "How many?" *num)
    (format "/n*** HEAP ***/n") 
    (print_heap1 0 *num))

(as (print_heap1 *n *num)
    (== *n *num) 
    (cut))
(as (print_heap1 *n *num)
    (HEAP *v)
    (nth *v *n *val)
    (format "/a : /p /n" *n *val)
    (add1 *n *n1)
    (print_heap1 *n1 *num))
			    
; fetch cycle on Runtime stack
(as (fetch *oadr *oadr) (ointp *oadr)(cut))
(as (fetch *oadr *oadr) (conp *oadr)(cut))
(as (fetch *oadr *oadr) (undefp *oadr) (cut))
(as (fetch *oadr *oadr) (atomp *oadr) (cut))    
(as (fetch *oadr *nadr) (> *oadr GVARTAG)(cut)
    (and (untagged var *oadr *oadr2)(hfetch *oadr2 *nadr)))
(as (fetch *oadr *nadr)
    (RS *v)
    (nth *v *oadr *xadr)
    (fetch *xadr *nadr))
; fetch cycle on Heap stack
(as (hfetch *oadr *oadr) (hconp *oadr)(cut))
(as (hfetch *oadr *oadr) (hundefp *oadr) (cut))
(as (hfetch *oadr *oadr) (hatomp *oadr) (cut))    
(as (hfetch *oadr *oadr) (hnilp *oadr) (cut))    
(as (hfetch *oadr *nadr)
    (HEAP *heap)
    (nth *heap *oadr *xadr)
    (hfetch *xadr *nadr))
; general fetch cycle 
(as (FETCH *oadr *oadr) (Oint *oadr)(cut))
(as (FETCH *oadr *oadr) (CONS *oadr)(cut))
(as (FETCH *oadr *oadr) (UNDEF *oadr) (cut))
(as (FETCH *oadr *oadr) (ATOM *oadr) (cut))    
(as (FETCH *oadr *oadr) (NIL *oadr) (cut))    
(as (FETCH *oadr *nadr)
    (NTH *oadr *xadr)
    (FETCH *xadr *nadr))
; cons fetch cycle (search like Runtime on Heap) 
(as (consFetch *oadr *oadr) (UNDEF *oadr) (cut))
(as (consFetch *oadr *oadr) (ATOM *oadr) (cut))    
(as (consFetch *oadr *oadr) (NIL *oadr) (cut))    
(as (consFetch *oadr *nadr)
    (numberp *oadr)(cut)
    (NTH *oadr *xadr)
    (consFetch *xadr *nadr))

; Do *adr point UNDEF?
(as (undefp \?)(cut))
(as (undefp *adr)
    (numberp *adr)
    (< *adr HEAPTAG)(cut)
    (RS *)
    (nth * *adr **)
    (= ** \?))

; *adr is negative then *adr OinterOBJ 
(as (ointp *adr)
    (numberp *adr)
    (< *adr 0))
(as (ointp *adr)
    (numberp *adr)
    (> *adr 0)
    (< *adr HEAPTAG)(cut)
    (RS *)
    (nth * *adr **)
    (numberp **)
    (< ** 0))

(as (hundefp \?)(cut))
(as (hundefp *adr)
    (numberp *adr)(cut)
    (HEAP *)
    (if (>= *adr HEAPTAG)(untagged cons *adr *adr2)(= *adr2 *adr))
    (nth * *adr2 **)
    (= ** \?))

; Do *adr point VAR?
(as (varp *adr)
    (and (not (undefp *adr))(not (conp *adr))(not (atomp *adr)))(cut))

(as (hvarp *adr)
    (and (not (hnilp *adr))(not (hundefp *adr))
	 (not (hconp *adr))(not (hatomp *adr)))(cut))

; Do *adr point CONS?
(as (conp *adr)
    (numberp *adr)
    (>= *adr HEAPTAG)
    (< *adr GVARTAG))
(as (conp *adr)
    (numberp *adr)
    (RS *)
    (< *adr HEAPTAG)
    (nth * *adr **)
    (numberp **)
    (>= ** HEAPTAG)
    (< ** GVARTAG))

(as (hconp *adr)
    (numberp *adr)(cut)
    (>= *adr HEAPTAG)
    (< *adr GVARTAG))
(as (hconp *adr)
    (numberp *adr)
    (HEAP *)
    (nth * *adr **)
    (numberp **)
    (>= ** HEAPTAG)
    (< ** GVARTAG))

; Do *adr point ATOM?
(as (atomp \?)(cut)(false))
(as (atomp *adr)
;    (> *adr NEWATOM)
     (not(numberp *adr))(cut)
     (atom *adr))
(as (atomp *adr)
    (numberp *adr)
    (< *adr HEAPTAG)
    (RS *)
    (nth * *adr **)
    (not (numberp **))
    (/= ** \?)
    (atom **))

(as (hatomp \?)(cut)(false))
(as (hatomp NIL)(cut)(false))
(as (hatomp *adr)
;    (> *adr NEWATOM)
     (not(numberp *adr))(cut)
     (/= *adr \?)
     (/= *adr NIL)
     (atom *adr))
(as (hatomp *adr)
    (numberp *adr)
    (HEAP *)
    (if (>= *adr HEAPTAG)(untagged cons *adr *adr2)(= *adr *adr2))
    (nth * *adr2 **)
    (not (numberp **))
    (/= ** \?)
    (/= ** NIL)
    (atom **))

(as (hnilp NIL)(cut))

(as (trailpush *adr *value)
    (:= *adr2 *adr)
    (TRAIL *tr)
    (replace *tr TRREG (*adr2 *value))
    (++ TRREG))

; vertual machine instruction

(as (vmmore)
    (varprint 2 QSS)
    (rind "more? y/n" n)(cut)
    (setv PC PCOUNTER))

(as (varprint *n *num)
    (=:= *n *num) 
    (cut))
(as (varprint *n *num)
    (setv HEAPFLAG OFF)
    (fetchAll *n *sex)
    (pprint *sex)
    (add1 *n *n1)
    (varprint *n1 *num))

(as (fetchAll *adr *sex)
    (Fetch *adr *Nadr)
    (NTH  *Nadr *cont)
    (cond ((UNDEF *cont)
           (= *sex "?"))
          ((CONS *cont)
	   (setv HEAPFLAG ON)
           (fetchAll *cont *carsex)
           (:= *cdr (+ *cont 1))
           (fetchAll *cdr *cdrsex)
           (= *sex (*carsex . *cdrsex))
	   (setv HEAPFLAG OFF))
	  ((NIL *cont)(= *sex ()))
	  ((Oint *cont)
	   (:= *c (- *cont))
	   (if (CONS *c)	   
	   (and(setv HEAPFLAG ON)
           (fetchAll *c *carsex)
           (:= *cdr (+ *c 1))
           (fetchAll *cdr *cdrsex)
           (= *cAll (*carsex . *cdrsex))
	   (setv HEAPFLAG OFF))
	   (fetchAll *c *cAll))
	   (= *sex (\* *c ~ *cAll))) 
          ((ATOM *cont) (= *sex *cont))))

(as (Fetch *adr *nadr) (=:= HEAPFLAG OFF)(cut)(fetch *adr *nadr))
(as (Fetch *adr *nadr) (=:= HEAPFLAG ON)(cut)(hfetch *adr *nadr))

(as (NTH  *n *con) (> HEAPTAG *n)(=:= HEAPFLAG OFF) (cut)    (RS *v)
    (nth *v *n *con))
(as (NTH  *n *con) (> HEAPTAG *n)(=:= HEAPFLAG ON) (cut)    (HEAP *v)
    (nth *v *n *con))
(as (NTH  *n *con) (:= *N (- *n HEAPTAG))  (HEAP *v)
    (nth *v *N *con))

; value check (direct)
(as (NIL NIL))
(as (UNDEF *cont)
    (== *cont \?))
(as (CONS *cont)
    (numberp *cont)
    (>= *cont HEAPTAG))
(as (ATOM *cont)
    (not (numberp *cont))
    (atom *cont))
(as (Oint *cont)
    (numberp *cont)
    (< *cont 0))

(as (regoffset *reg *ans)
    (:= *ans (+ *reg RREG)))

; getVariable *reg *var
; Variable is represented by offset number of ENVREG
; "getVar" substitute register's value to variable

(as (getVar *reg *var)
    (RS *stc)
    (REG *register)
    (:= *varnum (+ ENVREG *var))
    (regoffset *reg *rreg)
    (nth *register *rreg *adr)
    (nth *stc *varnum *value)
    (trailpush *varnum *value)
    (replace *stc *varnum *adr)
    (if (=:= PRINT_FLAG 1)
	(and (COMMENT *comt)(replace *comt *varnum BINDING))))

;getVal *reg *var general unification routine
(as (getVal *reg *var)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *value)
    (if (== *value \?)(= *value2 *varnum)(= *value2 *value))
    (reglook *reg *adr)
    (fetch *value2 *fetchvalue)
    (fetch *adr *fetchadr)
    (getValsub *fetchvalue *fetchadr))
; subroutine (getVal)
;case --- reg is var with con  ,  var is UNDEF
(as (getValsub *reg *var)
    (undefp *var)
    (ointp *reg)
    (Nth *var *old)
    (trailpush *var *old)
    (Replace *var *reg))
;case --- reg is UNDEF  ,  var is UNDEF
(as (getValsub *reg *var)
    (undefp *reg)
    (undefp *var)
    (if (> *var *reg)
	(and (Nth *var *old)
	     (trailpush *var *old)
	     (Replace *var *reg))
      (and (Nth *reg *old)
	   (trailpush *reg *old)
	   (Replace *reg *var))))
;case --- reg is ATOM or CONS ,  var is UNDEF
(as (getValsub *reg *var)
    (undefp *var)
    (or (conp *reg)(atomp *reg))
    (Nth *var *old)
    (trailpush *var *old)
    (Replace *var *reg))
;case --- reg is UNDEF , var is ATOM or CONS
(as (getValsub *reg *var)
    (undefp *reg)
    (or (conp *var)(atomp *var))
    (Nth *reg *old)
    (trailpush *reg *old)
    (Replace *reg *var))
;case --- reg is ATOM , var is ATOM
(as (getValsub *reg *var)
    (atomp *reg)
    (atomp *var)
    (== *reg *var))
;case --- reg is ATOM , var is CONS
(as (getValsub *reg *var)
    (atomp *reg)
    (conp *var)
    (false))
;case --- reg is CONS , var is ATOM
(as (getValsub *reg *var)
    (conp *reg)
    (atomp *var)
    (false))
;case --- reg is CONS , var is CONS
(as (getValsub *reg *var)
    (conp *reg)
    (conp *var)
    (untagged cons *reg *untag1)
    (untagged cons *var *untag2)
    (unifycons *reg *var *untag1 *untag2 0))

; getSymConstant *reg *atom
; "getSymCon" 
;case --- *reg is UNDEF
(as (getSymCon *reg  *atom)
    (reglook *reg *adr1)
    (fetch *adr1 *adr2)
    (undefp *adr2)
    (nth *stc *adr2 *value)
    (trailpush *adr2 *value)
    (replace *stc *adr2 *atom))
;case --- *reg is notUNDEF
(as (getSymCon *reg  *atom)
    (reglook *reg *adr1)
    (fetch *adr1 *adr2)
    (not (undefp *adr2))
    (== *adr2 *atom))

; getTVal *reg1 *reg2
; Unify Reg1 Reg2
(as (getTVal *reg1 *reg2)
    (reglook *reg1 *r1)
    (reglook *reg2 *r2)
    (fetch *r1 *r11)
    (fetch *r2 *r22)
    (getTValsub *r11 *r22))
; ----- subroutine (getTVal)
;  ----- reg1 is undef reg2 is atom or cons
(as (getTValsub *r11 *r22)
    (RS *stc)
    (undefp *r11)
    (or (conp *r22)(atomp *r22))(cut)
    (trailpush *r11 \?)
    (replace *stc *r11 *r22))
;----- reg1 is atom or cons reg2 is undef
(as (getTValsub *r11 *r22)
    (RS *stc)
    (undefp *r22)
    (or (conp *r11)(atomp *r11))(cut)
    (trailpush *r22 \?)
    (replace *stc *r22 *r11))
;----- reg1 reg2 both undef
(as (getTValsub *r11 *r22)
    (RS *stc)
    (undefp *r22)
    (undefp *r11)(cut)
    (if (> *r22 *r11)
	(and (trailpush *r22 \?)(replace *stc *r22 *r11))
      (and (trailpush *r11 \?)(replace *stc *r11 *r22))))
; ----- reg1 reg2 both atom
(as (getTValsub *r11 *r22)
    (atomp *r11)
    (atomp *r22)(cut)
    (== *r11 *r22))
; ----- reg1 is atom reg2 is cons
(as (getTValsub *r11 *r22)
    (atomp *r11)
    (conp *r22)(cut)
    (false))
; ----- reg1 is cons reg2 is atom
(as (getTValsub *r11 *r22)
    (conp *r11)
    (atomp *r22)(cut)
    (false))
; ----- reg1 reg2 both cons
(as (getTValsub *r11 *r22)
    (conp *r11)
    (conp *r22)(cut)
    (untagged cons *r11 *untagr1)
    (untagged cons *r22 *untagr2)
    (unifycons *r11 *r22 *untagr1 *untagr2 0))

(as (putSymCon *reg *atom)
    (REG *)
    (regoffset *reg *rreg)
    (replace * *rreg *atom))

(as (putVal *reg *var)
    (RS *)
    (REG *register)
    (:= *v (+ ENVREG *var))
    (nth * *v *value)
    (fetch *value *newvalue)
    (regoffset *reg *rreg)
    (replace *register *rreg *newvalue))

(as (putUVal *reg *var)
    (RS *stc)
    (REG *register)
    (HEAP *heap)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (:= *v (+ ENVREG *var))
    (nth *stc *v *value)
    (fetch *value *fetvalue)
    (replace *heap HREG *fetvalue)
    (tagged var HREG *tag)
    (replace *register *rreg *tag)
    (++ HREG))

(as (putVar *reg *var)
    (RS *stc)
    (REG *register)
    (:= *v (+ ENVREG *var))
; Initialize the *var
    (replace *stc *v \?)
    (regoffset *reg *rreg)
    (replace *register *rreg *v))

(as (putTVar *reg)
    (RS *stc)
    (REG *register)
    (HEAP *heap)
    (replace *heap HREG \?)
    (:= *hreg HREG)
    (tagged cons *hreg *tag)
    (regoffset *reg *rreg)
    (replace *register *rreg *tag))   ; Caution! HREG not increment

(as (putTTVar *reg *var)
    (RS *stc)
    (REG *register)
    (HEAP *heap)
    (replace *heap HREG \?)
    (:= *hreg HREG)
    (tagged cons *hreg *tag)
    (regoffset *reg *rreg)
    (replace *register *rreg *tag)   ; Caution! HREG not increment
    (:= *v (+ ENVREG *var))
    (nth *stc *v *old)
    (trailpush *v *old)
    (replace *stc *v *tag))
	
(as (moveReg *reg1 *reg2)
    (regoffset *reg1 *rreg1)
    (regoffset *reg2 *rreg2)
    (REG *register)
    (nth *register *rreg2 *r2)
    (replace *register *rreg1 *r2))

(as (call *label *num)
    (setv RETREG  PC)
    (setv PC *label))

(as (proceed)
    (setv PC RETREG))

(as (alloc)
    (<= BREG ENVREG)
    (:= *parent ENVREG)
    (:= *retreg RETREG)
    (RS *)
    (COMMENT *comt)
    (getstacksize *stacksize)
    (replace * (+ ENVREG *stacksize) *parent)
    (if (=:= PRINT_FLAG 1)(replace *comt (+ ENVREG *stacksize) PARENT))
    (replace * (+ ENVREG *stacksize 1) *retreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (+ ENVREG *stacksize 1) RETURN))
    (:= *newenv (+ ENVREG *stacksize))
    (setv ENVREG *newenv))
(as (alloc)
    (> BREG ENVREG)
    (:= *breg BREG)
    (:= *parent ENVREG)
    (:= *retreg RETREG)
    (RS *)
    (COMMENT *comt)
    (replace * *breg *parent)
    (if (=:= PRINT_FLAG 1)(replace *comt *breg PARENT))
    (replace * (+ *breg 1) *retreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (+ *breg 1) RETURN))
    (setv ENVREG *breg))

(as (exec *label)
    (setv PC *label))

(as (dealloc)
    (RS *stc)
    (nth *stc ENVREG *parent)
    (nth *stc (+ ENVREG 1) *retreg)
    (setv ENVREG *parent)
    (setv RETREG *retreg))

; 7 ..... CREGS.. CBREG CHREG CRREG CTRREG CRETREG CENVREG NEXTCL
(as (tryMeElse *regnum *label)
    (:= *tempbreg BREG)
    (:= *env ENVREG)
    (if (> *tempbreg *env)
	(:= *newbreg (+ BREG *regnum 7))
      (getstacksize *stacksize)
      (:= *newbreg (+ ENVREG *stacksize *regnum 7)))
    (setv BREG *newbreg)
    (RS *rt)
    (COMMENT *comt)
					; NEXTCL
    (replace *rt (- BREG 1) *label)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 1) NEXTCL))
					; CENVREG
    (:= *envreg ENVREG)
    (replace *rt (- BREG 2) *envreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 2) CENVREG))
					; CRETREG
    (:= *retreg RETREG)
    (replace *rt (- BREG 3) *retreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 3) CRETREG))
					; CTRREG
    (:= *trreg TRREG)
    (replace *rt (- BREG 4) *trreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 4) CTRREG))
					; CRREG
    (:= *rreg RREG)
    (replace *rt (- BREG 5) *rreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 5) CRREG))
					; CHREG
    (:= *hreg HREG)
    (replace *rt (- BREG 6) *hreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 6) CHREG))
					; CBREG
    (replace *rt (- BREG 7) *tempbreg)
    (if (=:= PRINT_FLAG 1)(replace *comt (- BREG 7) CBREG))
					; *regnum Registers save 
    (regsave *regnum (- BREG 8)))

(as (regsave *regnum *pos)
    (add1 *regnum *end)
    (regsave1 1 *end *pos))

(as (regsave1 *same *same ?)(cut))
(as (regsave1 *start *end *pos)
    (REG *register)
    (RS *rt)
    (regoffset *start *start2)
    (nth *register *start2 *regvalue)
    (replace *rt *pos *regvalue)
    (if (=:= PRINT_FLAG 1)(replace *comt *pos REG))
    (sub1 *pos *pos1)
    (add1 *start *start1)
    (regsave1 *start1 *end *pos1))
  
(as (retryMeElse *regnum *label)
    (RS *rt)
					; newNEXTCL store
    (replace *rt (- BREG 1) *label)
					; CENVREG restore
    (nth *rt (- BREG 2) *envreg)
    (setv ENVREG *envreg)
					; CRETREG restore
    (nth *rt (- BREG 3) *retreg)
    (setv RETREG *retreg)
    					; CTRREG restore
    (nth *rt (- BREG 4) *trreg)
    (restoreVar *trreg TRREG)
					;from *trreg to TRREG,restore var
    (setv TRREG *trreg)
					; CRREG restored
    (nth *rt (- BREG 5) *rreg)
    (setv RREG  *rreg)
					; CHREG restored
    (nth *rt (- BREG 6) *hreg)
    (setv HREG  *hreg)
					; *regnum Registers restore 
    (:= *regpos (- BREG 8))					  
    (regload *regnum *regpos))

(as (regload *regnum *pos)
    (:= *end (- *pos *regnum))
    (regload1 *pos *end 1))

(as (regload1 *num *num ?)(cut))
(as (regload1 *start *end *pos)
    (REG *register)
    (RS *rt)
    (nth *rt *start *cregvalue)
    (regoffset *pos *pos2)
    (replace *register *pos2 *cregvalue)
    (add1 *pos *pos1)
    (sub1 *start *start1)
    (regload1 *start1 *end *pos1))

(as (restoreVar *num *tr)
    (=:= *num *tr)
    (cut))
(as (restoreVar *start *end)
    (TRAIL *tr)
    (nth *tr *start *restore)
    (= *restore (*adr *value))
    (< *adr HEAPTAG) (cut)
    (RS *rt)
    (replace *rt *adr *value)
    (add1 *start *start1)
    (restoreVar *start1 *end))
(as (restoreVar *start *end)          ;for HEAP
    (TRAIL *tr)
    (nth *tr *start *restore)
    (= *restore (*adr *value))
    (>= *adr HEAPTAG) (cut)
    (HEAP *heap)
    (untagged cons *adr *adr2)
    (replace *heap *adr2 *value)
    (add1 *start *start1)
    (restoreVar *start1 *end))

(as (trustMeElseFail *regnum)
    (RS *rt)
					; CENVREG restore
    (nth *rt (- BREG 2) *envreg)
    (setv ENVREG *envreg)
					; CRETREG restore
    (nth *rt (- BREG 3) *retreg)
    (setv RETREG *retreg)    
					; CTRREG restore
    (nth *rt (- BREG 4) *trreg)
    (restoreVar *trreg TRREG)
					;from *trreg to TRREG restore var
    (setv TRREG *trreg)
					; CRREG restored
    (nth *rt (- BREG 5) *rreg)
    (setv RREG  *rreg)
					; CHREG restored
    (nth *rt (- BREG 6) *hreg)
    (setv HREG  *hreg)
					; *regnum Registers restore 
    (regload *regnum (- BREG 8))
                                        ; CBREG restored
    (nth *rt (- BREG 7) *breg)
    (setv BREG *breg))

; instruction for CUT operator

(as (getBreg *varnum)
    (:= *tbreg BREG)
    (RS *rt)
    (replace *rt (+ ENVREG *varnum) *tbreg))

(as (getTBreg *regnum)
    (:= *tbreg BREG)
    (REG *register)
    (regoffset *regnum *regnumn)
    (replace *register *regnumn *tbreg))

(as (putBreg *varnum)
    (RS *rt)
    (nth *rt (+ ENVREG *varnum) *value)
    (setv BREG *value))
;    (nth *rt (- BREG 7) *hbreg)
;    (setv HBREG *hbreg))

(as (putTBreg *regnum)
    (REG *register)
    (regoffset *regnum *nregnum)
    (nth *register *nregnum *value)
    (setv BREG *value))
;    (nth *rt (- BREG 7) *hbreg)
;    (setv HBREG *hbregOA))

(as (getstacksize 0)
    (=:= RETREG 0)(cut))
(as (getstacksize *stacksize)
    (PAREA *program)
    (nth *program (- RETREG 1) (call ? *stacksize)))
(as (getstacksize *stacksize)
    (PAREA *program)
    (nth *program (- RETREG 1) (Call  *stacksize)))

; Instruction for HEAP (body)

(as (putNil *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (replace *register *rreg NIL))
 
(as (putCons *reg)
    (REG *register)
    (:= *hreg HREG)
    (tagged cons *hreg *taghreg)
    (regoffset *reg *rreg)
    (replace *register *rreg *taghreg )) ;Tagged

(as (putTCons *reg)          ; syntax sugar. This instruction same as putCons.
    (REG *register)
    (:= *hreg HREG)
    (tagged cons *hreg *taghreg)
    (regoffset *reg *rreg)
    (replace *register *rreg *taghreg)
    (++ HREG))

(as (bldTVal *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (HEAP *heap)
    (hregtrailpush)
    (replace *heap HREG *regvalue)
    (++ HREG))

(as (bldVar *var)
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *oldvalue)
    (trailpush *varnum *oldvalue)
    (:= *hreg HREG)
    (tagged cons *hreg *taghreg)
    (replace *stc *varnum *taghreg)
    (hregtrailpush)
    (replace *heap HREG \?) ;initialize
    (++ HREG))

(as (bldSymCon *atom)
    (HEAP *heap)
    (hregtrailpush)
    (replace *heap HREG *atom)
    (++ HREG))

(as (bldNil)
    (HEAP *heap)
    (hregtrailpush)
    (replace *heap HREG NIL)
    (++ HREG))

(as (bldVal *var)
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (fetch *varnum *value)
    (undefp *value)(cut)           ;If *var pointed free variable X
    (nth *stc *value *oldvalue)    ;Make new heap area for X
    (trailpush *value *oldvalue)
    (tagged cons HREG *taghreg)
    (replace *stc *value *taghreg) ;X pointed new heap area
    (hregtrailpush)
    (replace *heap HREG \?) ;initialize
    (++ HREG))
(as (bldVal *var)   ; If *var not UNDEF
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (fetch *varnum *value)
    (hregtrailpush)
    (replace *heap HREG *value)
    (++ HREG))

(as (hregtrailpush)
    (HEAP *heap)
    (:= *hreg HREG)
    (tagged cons *hreg *threg)
    (nth *heap *hreg *old)
    (trailpush *threg *old))

; Instruction for HEAP (HEAD)

(as (getNil *reg)              ;Suppose *reg pointed to HEAP
    (OnHeap *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (hfetch *regvalue *fetregvalue)
    (hundefp *fetregvalue)(cut)
    (searchadr *fetregvalue *point)
    (NTH *point *old)
    (trailpush *point *old)
    (Replace *point NIL))
(as (getNil *reg)
    (OnHeap *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (hfetch *regvalue *fetregvalue)
    (not(hundefp *fetregvalue))
    (HEAP *heap)
    (untagged cons *fetregvalue *untag)
    (numberp *untag)(cut)
    (nth *heap *untag *nil)
    (== *nil NIL))
(as (getNil *reg)
    (OnHeap *reg)(cut)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (hfetch *regvalue *fetregvalue)
    (== *fetregvalue NIL))
(as (getNil *reg)           ;Suppose *reg pointed to RS
    (REG *register)
    (RS *runt)
    (regoffset *reg *rreg)
    (nth *register *rreg *adr)
    (fetch *adr *Nadr)
    (nth *runt *Nadr *cont)
    (if (== *cont \?)(and (trailpush *Nadr \?)(replace *runt *Nadr NIL))
      (== *cont NIL)))
    
(as (getCons *reg)            ;Suppose *reg pointed to HEAP
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *value)
    (OnHeap *reg)
    (hfetch *value *fetchvalue)
    (hundefp *fetchvalue)(cut)
    (setv MODE_FLAG WRITE))
(as (getCons *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *value)
    (OnHeap *reg)
    (hfetch *value *fetchvalue)
    (hconp *fetchvalue)
    (setv MODE_FLAG READ)
    (untagged cons *fetchvalue *untag)
    (setv SREG *untag)) ;untagged
(as (getCons *reg)            ;Suppose *reg pointed to RS
    (REG *register)
    (RS *stc)
    (regoffset *reg *rreg)
    (nth *register *rreg *value)
    (fetch *value *fetchvalue)
    (undefp *fetchvalue)(cut)
    (:= *hreg HREG)
    (nth *stc *fetchvalue *old)
    (trailpush *fetchvalue *old)
    (tagged cons *hreg *tag)
    (replace *stc *fetchvalue *tag)
    (replace *register *rreg *tag)
    (setv MODE_FLAG WRITE))
(as (getCons *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *value)
    (fetch *value *fetchvalue)
    (conp *fetchvalue)
    (setv MODE_FLAG READ)
    (untagged cons *fetchvalue *untag)
    (setv SREG *untag)) ;untagged

(as (uniSymCon *atom)
    (=:= MODE_FLAG WRITE)(cut)
    (HEAP *heap)
    (hregtrailpush)
    (replace *heap HREG *atom)
    (++ HREG))
(as (uniSymCon *atom)
    (=:= MODE_FLAG READ)
    (HEAP *heap)
    (nth *heap SREG *adr)
    (hfetch *adr *value)
    (or (hnilp *value)(hatomp *value))(cut)
    (== *value *atom)
    (++ SREG))
(as (uniSymCon *atom)
    (=:= MODE_FLAG READ)
    (HEAP *heap)
    (nth *heap SREG *adr)
    (hfetch *adr *value)
    (hundefp *value)(cut)
    (nth *heap *value *old)
    (tagged cons *value *tag)
    (trailpush *tag *old) ;tagged
    (replace *heap *value *atom)
    (++ SREG))

(as (uniVar *var)
    (=:= MODE_FLAG WRITE)
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *oldvalue)
    (trailpush *varnum *oldvalue)
    (tagged cons HREG *taghreg)
    (replace *stc *varnum *taghreg)
    (:= *hreg HREG)
    (hregtrailpush)
    (replace *heap *hreg \?) ;initialize
    (++ HREG))
(as (uniVar *var)
    (=:= MODE_FLAG READ)
    (:= *sreg SREG)
    (hfetch *sreg *adr)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *value)
    (trailpush *varnum *value)
    (tagged cons *adr *tagadr)
    (replace *stc *varnum  *tagadr )
    (if (=:= PRINT_FLAG 1)(and (COMMENT *comt)(replace *comt *varnum toHEAP))))

;case --- sreg is UNDEF  ,  var is UNDEF
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *value)
    (fetch *value *fetchvalue)
    (undefp *fetchvalue)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hundefp *fetchadr)
    (nth *stc *fetchvalue *old)
    (trailpush  *fetchvalue *old)
    (tagged cons *fetchadr *tagadr)
    (replace *stc *fetchvalue *tagadr)
    (if (=:= PRINT_FLAG 1)(and (COMMENT *comt)(replace *comt *fetchvalue toHEAP))))
;case --- sreg is ATOM or CONS ,  var is UNDEF
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum *value)
    (fetch *value *fetchvalue)
    (undefp *fetchvalue)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (or (hconp *fetchadr)(hatomp *fetchadr))
    (nth *stc *fetchvalue *old)
    (trailpush *fetchvalue *old)
    (replace *stc *fetchvalue *fetchadr))
;case --- sreg is UNDEF , var is ATOM or CONS
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum  *varvalue)
    (:= *regadr SREG)
    (hfetch *regadr *fetchregadr)
    (hundefp *fetchregadr)
    (fetch *varvalue *fetchvarvalue)
    (or (conp *fetchvarvalue)(atomp *fetchvarvalue))
    (nth *stc *fetchregadr *old)
    (tagged cons *fetchregadr *tag)
    (trailpush *tag *old)
    (replace *heap *fetchregadr *fetchvarvalue))
;case --- sreg is ATOM , var is ATOM
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum  *value)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hatomp *fetchadr)
    (fetch *value *fetchvalue)
    (atomp *fetchvalue)
    (== *fetchadr *fetchvalue))
;case --- sreg is ATOM , var is CONS
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hatomp *fetchadr)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum  *value)
    (fetch *value *fetchvalue)
    (conp *fetchvalue)
    (false))
;case --- sreg is CONS , var is ATOM
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hconp *fetchadr)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum  *value)
    (fetch *value *fetchvalue)
    (atomp *fetchvalue)(cut)
    (false))
;case --- sreg is CONS , var is CONS
(as (uniVal *var)
    (=:= MODE_FLAG READ)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (nth *stc *varnum  *value)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hconp *fetchadr)
    (fetch *value *fetchvalue)
    (conp *fetchvalue)
    (untagged cons *fetchadr *utag1)
    (untagged cons *fetchvalue *utag2)
    (unifycons *fetchadr *fetchvalue *utag1 *utag2 0))
;case ---- for WRITE MODE  act as  bldbal!
(as (uniVal *var)
    (=:= MODE_FLAG WRITE)
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (fetch *varnum *value)
    (undefp *value)(cut)           ;If *var pointed free variable X
    (nth *stc *value *oldvalue)    ;Make new heap area for X
    (trailpush *value *oldvalue)
    (tagged cons HREG *taghreg)
    (replace *stc *value *taghreg) ;X pointed new heap area
    (hregtrailpush)
    (replace *heap HREG \?) ;initialize
    (++ HREG))
(as (uniVal *var)   ; If *var not UNDEF
    (=:= MODE_FLAG WRITE)
    (HEAP *heap)
    (RS *stc)
    (:= *varnum (+ ENVREG *var))
    (fetch *varnum *value)
    (hregtrailpush)
    (replace *heap HREG *value)
    (++ HREG))

; unitvar writes register (TAGGED)
(as (uniTVar *reg)
    (=:= MODE_FLAG WRITE)
    (HEAP *heap)
    (REG *register)
    (:= *hreg HREG)
    (:= *hreg2 (+ *hreg 1))
    (tagged cons *hreg2 *hreg3)
    (regoffset *reg *rreg)
    (replace *register *rreg *hreg3)
    (hregtrailpush)
    (replace *heap *hreg *hreg3) ; make next cons cell
    (++ HREG))                   ; but not fixed number(?)
(as (uniTVar *reg)
    (=:= MODE_FLAG READ)
    (:= *sreg SREG)
    (hfetch *sreg *adr)
    (REG *register)
    (tagged cons *adr *tagadr)
    (regoffset *reg *rreg)
    (replace *register *rreg *tagadr)
    (++ SREG))

(as (OnHeap *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *adr)
    (numberp *adr)(cut)
    (>= *adr HEAPTAG))
(as (OnHeap *reg)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *adr)
    (atom *adr))

(as (tagged cons *adr *tagadr)
    (numberp *adr)(cut)
    (if (>= *adr HEAPTAG)(= *adr *tagadr)
    (:= *tagadr (+ *adr HEAPTAG))))
(as (tagged cons NIL NIL))
(as (tagged var *adr *tagadr)
    (if (>= *adr GVARTAG)(= *adr *tagadr)
    (:= *tagadr (+ *adr GVARTAG))))
(as (tagged oint *adr *tagadr)
    (numberp *adr)(cut)
    (if (<= *adr 0)(= *adr *tagadr)
    (:= *tagadr (- *adr ))))

(as (untagged cons *adr *untaged)
    (numberp *adr)(cut)
    (if (< *adr HEAPTAG)(= *adr *untaged)
    (:= *untaged (- *adr HEAPTAG))))
(as (untagged cons NIL NIL))
(as (untagged var *adr *untaged)
    (if (< *adr GVARTAG)(= *adr *untaged)
    (:= *untaged (- *adr GVARTAG))))
(as (untagged oint *adr *untag)
    (numberp *adr)(cut)
    (if (>= *adr 0)(= *adr *tagadr)
    (:= *untag (- *adr ))))
    
; uniTval reg .... If reg not on heap then uniTVal failure
;case --- sreg is UNDEF  ,  reg is UNDEF (on HEAP)
(as (uniTVal *reg)
    (OnHeap *reg)
    (=:= MODE_FLAG READ)
    (REG *register)
    (regoffset *reg *rreg)
    (nth *register *rreg *value)
    (if (numberp *value)(untagged cons *value *value2)(= *value2 *value))
    (hfetch *value2 *fetchvalue)
    (hundefp *fetchvalue)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hundefp *fetchadr)(cut)
    (tagged cons *fetchadr *tagadr)
    (replace *register *rreg *tagadr)
    (++ SREG))
;case --- sreg is ATOM or CONS ,  reg is UNDEF
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg)
    (=:= MODE_FLAG READ)
    (REG *register)
    (nth *register *rreg *value)
    (consFetch *value *cont2)
    (UNDEF *cont2)              ; *value pointed UNDEF
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (or (hconp *fetchadr)(hatomp *fetchadr)(hnilp *fetchadr))(cut)
    (searchadr *value *pointvalue)
    (tagged cons *fetchadr *tag)
    (NTH *tag *cont)
    (replace *register *rreg *cont)
    (NTH *pointvalue *old)
    (trailpush *pointvalue *old)
    (Replace *pointvalue *cont)
    (++ SREG))
;case --- sreg is UNDEF , reg is ATOM or CONS
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg)
    (HEAP *heap)
    (=:= MODE_FLAG READ)
    (REG *register)
    (nth *register *rreg  *regvalue)
    (:= *regadr SREG)
    (hfetch *regadr *fetchregadr)
    (hundefp *fetchregadr)
    (hfetch *regvalue *fetchregvalue)
    (or (hconp *fetchregvalue)
	(hatomp *fetchregvalue)(hnilp *fetchregvalue))(cut)
    (NTH *heap *regadr2 *old)
    (tagged cons *regadr2 *tag)
    (trailpush *tag *old)
    (FETCH *regadr *cont)
    (replace *heap *regadr2 *cont)
    (++ SREG))
;case --- sreg is ATOM , reg is ATOM
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg)
    (=:= MODE_FLAG READ)
    (REG *register)
    (nth *register *rreg *value)
    (if (numberp *value)(untagged cons *value *value2)(= *value *value2))
    (hfetch *value2 *fetchvalue)
    (or (hatomp *fetchvalue)(hnilp *fetchvalue))
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (or (hatomp *fetchadr)(hnilp *fetchadr))(cut)
    (tagged cons *fetchadr *t1)
    (tagged cons *fetchvalue *t2)
    (NTH *t1 *cont1)
    (NTH *t2 *cont2)
    (== *cont1 *cont2)
    (++ SREG))
;case --- sreg is ATOM , var is CONS
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg) 
    (=:= MODE_FLAG READ)
    (REG *register)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (or (hatomp *fetchadr)(nilp *fetchadr))
    (nth *register *rreg  *value)
    (if (numberp *value)(untagged cons *value *value2)(= *value *value2))
    (hfetch *value2 *fetchvalue)
    (hconp *fetchvalue)(cut)
    (false))
;case --- sreg is CONS , var is ATOM
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg)
    (=:= MODE_FLAG READ)
    (REG *register)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hconp *fetchadr)
    (nth *register *rreg  *value)
    (if (numberp *value)(untagged cons *value *value2)(= *value *value2))
    (hfetch *value2 *fetchvalue)
    (or (hatomp *fetchvalue)(hnilp *fetchvalue))(cut)
    (false))
;case --- sreg is CONS , var is CONS
(as (uniTVal *reg)
    (regoffset *reg *rreg)
    (OnHeap *rreg)
    (=:= MODE_FLAG READ)
    (REG *register)
    (nth *register *rreg  *value)
    (:= *adr SREG)
    (hfetch *adr *fetchadr)
    (hconp *fetchadr)
    (if (numberp *value)(untagged cons *value *value2)(= *value *value2))
    (hfetch *value2 *fetchvalue)
    (conp *fetchvalue)(cut)
    (untagged cons *fetchadr *utag1)
    (untagged cons *fetchvalue *utag2)
    (unifycons *fetchadr *fetchvalue *utag1 *utag2 0)
    (++ SREG))
;case ---- for WRITE MODE  act as  bldTbal!
(as (uniTVal *reg)
    (=:= MODE_FLAG WRITE)(cut)
    (REG *register)
    (HEAP *heap)
    (regoffset *reg *rreg)
    (nth *register *rreg *regvalue)
    (hfetch *regvalue *fet)
    (if (numberp *fet)
	(and (untagged cons *fet *unfet)(nth *heap *unfet *cont))
      (= *regvalue *cont))
    (hregtrailpush)
    (replace *heap HREG *cont)
    (++ HREG))

(as (unifycons *atom *cons ? ? 0)     ;first loop 
    (atomp *atom)
    (hconp *cons)(cut)
    (false))
(as (unifycons *cons *atom ? ? 0)     ;first loop
    (atomp *atom)
    (hconp *cons)(cut)
    (false))
(as (unifycons *undef *atom *adr1 *adr2 1)
    (hundefp *undef)
    (hatomp *atom)
    (HEAP *heap)
    (tagged cons *adr1 *tag)
    (trailpush *tag \?) ;oldvalue UNDEF
    (hfetch *atom *adr22)
    (hfetch *undef *adr11)  
    (searchadr *adr11 *undefadr)
                      ;*undefadr pointed "?"
    (NTH *undefadr *oldvalue)
    (trailpush *undefadr *oldvalue)
    (Replace  *undefadr *adr22)
    (++ HREG))
(as (unifycons *atom *undef *adr2 *adr1 1)
    (hundefp *undef)
    (hatomp *atom)
    (HEAP *heap)
    (tagged cons *adr1 *tag)
    (trailpush *tag \?) ;oldvalue UNDEF
    (hfetch *atom *adr22)
    (hfetch *undef *adr11)
    (searchadr *adr11 *undefadr)
                      ;*undefadr pointed "?"
    (NTH *undefadr *oldvalue)
    (trailpush *undefadr *oldvalue)
    (Replace  *undefadr *adr22)
    (++ HREG))
(as (unifycons *undef NIL *adr1 ? 1)
    (hundefp *undef)
    (HEAP *heap)
    (tagged cons *adr1 *tag)
    (trailpush *tag \?) ;oldvalue UNDEF
    (replace *heap *adr1 NIL)
    (++ HREG))
(as (unifycons NIL *undef ? *adr1 1)
    (hundefp *undef)
    (HEAP *heap)
    (tagged cons *adr1 *tag)
    (trailpush *tag \?) ;oldvalue UNDEF
    (replace *heap *adr1 NIL)
    (++ HREG))
(as (unifycons *atom1 *atom2 ? ? 1)
    (hatomp *atom1)
    (hatomp *atom2)(cut)
    (HEAP *heap)
    (hfetch *atom1 *atom3)
    (if (numberp *atom3)
	(and (untagged cons *atom3 *atom33)(nth *heap *atom33 *atom5))
      (= *atom3 *atom5))
    (hfetch *atom2 *atom4)
    (if (numberp *atom4)
	(and (untagged cons *atom4 *atom44)(nth *heap *atom44 *atom6))
      (= *atom4 *atom6))
    (== *atom5 *atom6))
(as (unifycons *undef1 *undef2 *adr1 *adr2 1)
    (> *adr1 *adr2)
    (hundefp *undef1)
    (hundefp *undef2)(cut)
    (tagged cons *adr1 *tag)
    (trailpush *tag \?)
    (HEAP *heap)
    (replace *heap *adr1 *adr2))
(as (unifycons *undef1 *undef2 *adr1 *adr2 1)
    (< *adr1 *adr2)
    (hundefp *undef1)
    (hundefp *undef2)(cut)
    (tagged cons *adr2 *tag)
    (trailpush *tag \?)
    (HEAP *heap)
    (replace *heap *adr2 *adr1))
; value1 ,2 is To heap pointer 
(as (unifycons *value1 *value2 *adr1 *adr2 ?)
    (hvarp *value1)
    (hvarp *value2)(cut)
    (HEAP *heap)
    (nth *heap *value1 *nv1)
    (nth *heap *value2 *nv2)
    (unifycons *nv1 *nv2 *value1 *value2 1))
(as (unifycons *value1 *value2 *adr1 *adr2 ?)
    (hvarp *value1)
    (not (hvarp *value2))
    (HEAP *heap)
    (nth *heap *value1 *nv1)
    (unifycons *nv1 *value2 *value1 *adr2 1))
(as (unifycons *value1 *value2 *adr1 *adr2 ?)
    (not (hvarp *value1))
    (hvarp *value2)
    (HEAP *heap)
    (nth *heap *value2 *nv2)
    (unifycons *value1 *nv2 *adr1 *value2 1))
(as (unifycons *value1 *value2 *adr1 *adr2 ?)
    (not (hvarp *value1))
    (not (hvarp *value2))
    (unifycons *value1 *value2 *adr1 *adr2 1))

(as (Replace *adr *value)
    (< *adr HEAPTAG)(cut)
    (RS *runtime)
    (replace *runtime *adr *value))
(as (Replace *adr *value)
    (> *adr HEAPTAG)(cut)
    (:= *adr2 (- *adr HEAPTAG))
    (HEAP *heap)
    (replace *heap *adr2 *value))

(as (searchadr *adr *undef)
    (setv ADDR -1)
    (stackend *stend)
    (dotimes *i *stend
	     (RS *rt)
	     (nth *rt *i *value)
	     (if (== *value *adr)(setv  ADDR *i)))
    (:= *hreg HREG)
    (dotimes *i *hreg
	     (HEAP *heap)
	     (nth *heap *i *value)
	     (if (== *value *adr)(and (tagged cons *i *ii)(setv ADDR *ii))))
    (if (=:= ADDR -1)(= *undef *adr)(:= *undef ADDR)))

(as (stackend *stend)
    (:= *env ENVREG)
    (:= *breg BREG)
    (:= *stend (max *env *breg)))

;----------------------------------
; Ointersect

(setv Intersect 0)
(setv Member 1)

(as (regset *num *cont)
    (REG *reg)
    (regoffset *num *nnum)
    (replace *reg *nnum *cont))

(as (reglook *adr *cont)
    (REG *register)
    (regoffset *adr *nadr)
    (nth *register *nadr *cont))

(as (varlook *adr *cont)
    (RS *rs)
    (:= *addr (+ ENVREG *adr))
    (nth *rs *addr *cont))

; putI *reg with Information
(as (putI *reg *offsetreg)
    (reglook *reg *cont)
    (FETCH *cont *addr)
    (Oint *addr)(cut)
    (setv OMODE Intersect)
    (untagged oint *addr *con2)
    (regset *offsetreg *con2))              ;set value to reg(offset1) 
(as (putI *reg)
    (reglook *reg *con)
    (FETCH *con *cont)
    (ATOM *cont)(cut)
    (setv OMODE Member)
    (regset *offsetreg *cont))

; putIVar *register1 *var *register2 : *reg(pointed Information)
(as (putIVar *reg *var *reg2)
    (NTH *var *old)
    (:= *vv (+ ENVREG *var))
    (trailpush *vv *old)
    (reglook *reg2 *regvalue)
    (tagged oint *regvalue *tagreg)
    (Replace *vv *tagreg)
    (regset *reg *vv))

; putIVal *reg *var
;   Ointersect/Omember give an answer to *var
;   *reg point to Information
(as (putIVal *reg *var)
    (=:= OMODE Intersect)
    (reglook *reg *addr)
    (varlook *var *addr2)
    (tagged oint *addr2 *tag)
    (varlook *addr *old)
    (trailpush *addr *old)
    (RS *rs)
    (replace *rs *addr *tag))

(as (Call *)
    (=:= OMODE Intersect)
    (LABEL_TAB (Ointersect 3) *addr)
    (setv RETREG PC)
    (setv PC *addr))
(as (Call *)
    (=:= OMODE Member)
    (LABEL_TAB (Omember 2) *addr)
    (setv RETREG PC)
    (setv PC *addr))

; if *reg is normal var then goto label2 , else goto label1
(as (switchOnVar *reg *label1 *label2)
    (reglook *reg *addr)
    (fetch *addr *cont)
    (if (varp *cont)(setv PC *label2)
      (setv PC *label1)))

; instruction for Ointersect operator

(as (ShiftReg *num)
    (setv RREG *num))

(as (getRreg *varnum)
    (:= *trreg RREG)
    (RS *rt)
    (replace *rt (+ ENVREG *varnum) *trreg))

(as (getTRreg *regnum)
    (:= *trreg RREG)
    (REG *register)
    (regoffset *regnum *regnumn)
    (replace *register *regnumn *trreg))

(as (putRreg *varnum)
    (RS *rt)
    (nth *rt (+ ENVREG *varnum) *value)
    (setv RREG *value))

(as (putTRreg *regnum)
    (REG *register)
    (regoffset *regnum *nregnum)
    (nth *register *nregnum *value)
    (setv RREG *value)
